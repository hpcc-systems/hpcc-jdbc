<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<book lang="en_US" xml:base="../">
  <bookinfo>
    <title>HPCC JDBC Driver</title>

    <mediaobject>
      <imageobject>
        <imagedata fileref="images/redswooshWithLogo3.jpg" />
      </imageobject>
    </mediaobject>

    <author>
      <surname>Boca Raton Documentation Team</surname>
    </author>

    <legalnotice>
      <para>We welcome your comments and feedback about this document via
      email to <email>docfeedback@hpccsystems.com</email> Please include
      <emphasis role="bold">Documentation Feedback</emphasis> in the subject
      line and reference the document name, page numbers, and current Version
      Number in the text of the message.</para>

      <para>LexisNexis and the Knowledge Burst logo are registered trademarks
      of Reed Elsevier Properties Inc., used under license. Other products,
      logos, and services may be trademarks or registered trademarks of their
      respective companies. All names and example data used in this manual are
      fictitious. Any similarity to actual persons, living or dead, is purely
      coincidental.</para>

      <para></para>
    </legalnotice>

    <xi:include href="common/Version.xml" xpointer="FooterInfo"
                xmlns:xi="http://www.w3.org/2001/XInclude" />

    <xi:include href="common/Version.xml" xpointer="DateVer"
                xmlns:xi="http://www.w3.org/2001/XInclude" />

    <corpname>HPCC Systems</corpname>

    <xi:include href="common/Version.xml" xpointer="Copyright"
                xmlns:xi="http://www.w3.org/2001/XInclude" />

    <mediaobject role="logo">
      <imageobject>
        <imagedata fileref="images/LN_Rightjustified.jpg" />
      </imageobject>
    </mediaobject>
  </bookinfo>

  <chapter>
    <title>Introduction</title>

    <para>Java Database Connectivity (<emphasis role="bold">JDBC</emphasis>)
    is a standard Java API that enables Java applications or client tools that
    support JDBC to access data from a<emphasis> presumably
    </emphasis>SQL-compliant data source via the SQL language.</para>

    <para><emphasis role="bold">JDBC</emphasis> makes it possible to write a
    single database application that can run on different platforms and
    interact with different database management systems.</para>

    <para>Currently there are JDBC Drivers available for interaction with many
    popular data sources; now the HPCC platform is available as a data
    source.</para>

    <para>The HPCC JDBC Driver exposes HPCC logical files as RDB
    tables.</para>

    <para><itemizedlist mark="bullet">
        <listitem>
          <para>HPCC Logical File &lt;-&gt; RDB Table</para>
        </listitem>

        <listitem>
          <para>HPCC Record Definition Fields &lt;-&gt; RDB Table
          Columns</para>
        </listitem>

        <listitem>
          <para>HPCC Published query &lt;-&gt; RDB Stored Procedure</para>
        </listitem>

        <listitem>
          <para>Provides HPCC system and data RDB metadata</para>
        </listitem>

        <listitem>
          <para>Supports subset of SQL syntax</para>
        </listitem>

        <listitem>
          <para>Read only operations supported</para>
        </listitem>

        <listitem>
          <para>Non transactional</para>
        </listitem>

        <listitem>
          <para>Provides means for utilizing HPCC index files for faster
          reads.</para>
        </listitem>
      </itemizedlist><figure>
        <title>An example SQL Client interface connected to an HPCC Platform
        with the JDBC driver</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="images/jdbc01.jpg" />
          </imageobject>
        </mediaobject>
      </figure></para>
  </chapter>

  <chapter>
    <title>Installation</title>

    <para>The HPCC JDBC driver is distributed in a self-contained JAVA jar
    file.</para>

    <para>Follow the instructions for your SQL client for installation.</para>

    <para>To utilize your HPCC platform, use the configuration settings in the
    next section. The manner in which you define these settings is dependent
    on your SQL client.</para>

    <para>The driver’s full class path is:</para>

    <para><emphasis
    role="bold">org.hpccsystems.jdbcdriver.HPCCDriver</emphasis></para>

    <para></para>
  </chapter>

  <chapter>
    <title>Configuration</title>

    <para>The HPCC JDBC driver supports the following configuration
    attributes:</para>

    <para><informaltable align="left" colsep="1" frame="all" rowsep="1">
        <tgroup cols="4">
          <colspec colwidth="120pt" />

          <colspec colwidth="3*" />

          <colspec colwidth="1*" />

          <colspec colwidth="35pt" />

          <thead>
            <row>
              <entry>Property</entry>

              <entry>Description</entry>

              <entry>Default Value</entry>

              <entry>Req.</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry>ServerAddress</entry>

              <entry>Target HPCC address</entry>

              <entry>“localhost”</entry>

              <entry>Yes</entry>
            </row>

            <row>
              <entry>WsECLWatchAddress</entry>

              <entry>Target HPCC WsECLWatch address</entry>

              <entry>ServerAddress Value</entry>

              <entry>No</entry>
            </row>

            <row>
              <entry>WsECLWatchPort </entry>

              <entry>Target HPCC WsECLWatch port</entry>

              <entry>8010</entry>

              <entry>No</entry>
            </row>

            <row>
              <entry>WsECLAddress</entry>

              <entry>Target HPCC WsECL Address</entry>

              <entry>ServerAddress Value</entry>

              <entry>No</entry>
            </row>

            <row>
              <entry>WsECLPort</entry>

              <entry>Target HPCC WsECL port</entry>

              <entry>8002</entry>

              <entry>No</entry>
            </row>

            <row>
              <entry>WsECLDirectAddress</entry>

              <entry>Target HPCC WsECLDirectAddress</entry>

              <entry>ServerAddress Value</entry>

              <entry>No</entry>
            </row>

            <row>
              <entry>WsECLDirectPort</entry>

              <entry>Target HPCC WsECLDirect port</entry>

              <entry>8010</entry>

              <entry>No</entry>
            </row>

            <row>
              <entry>Username</entry>

              <entry>User name on Target HPCC, if needed</entry>

              <entry>“”</entry>

              <entry>No</entry>
            </row>

            <row>
              <entry>Password</entry>

              <entry>Password on Target HPCC, if needed</entry>

              <entry>“”</entry>

              <entry>No</entry>
            </row>

            <row>
              <entry>PageSize</entry>

              <entry>Max Number of HPCC files or HPCC published queries
              reported as result of GetTables, or GetProcs</entry>

              <entry>100</entry>

              <entry>No</entry>
            </row>

            <row>
              <entry>ConnectTimeoutMilli</entry>

              <entry align="left">Timeout value to establish connection to
              HPCC (in milliseconds)</entry>

              <entry>1000</entry>

              <entry>No</entry>
            </row>

            <row>
              <entry>ReadTimeoutMilli</entry>

              <entry align="left">HPCC Connection <emphasis
              role="bold">read</emphasis> timeout value (in
              milliseconds)</entry>

              <entry>1500</entry>

              <entry>No</entry>
            </row>

            <row>
              <entry>EclResultLimit</entry>

              <entry>Max result records returned (use ALL to return all
              records)</entry>

              <entry>100</entry>

              <entry>No</entry>
            </row>

            <row>
              <entry>LazyLoad</entry>

              <entry>Fetch HPCC file and query metadata on-demand (not at
              connect time)</entry>

              <entry>“true”</entry>

              <entry>No</entry>
            </row>

            <row>
              <entry>TargetCluster</entry>

              <entry>ECLDirect target cluster</entry>

              <entry>“hthor”</entry>

              <entry>No</entry>
            </row>

            <row>
              <entry>QuerySet</entry>

              <entry>Target published query (stored procedure)
              QuerySet</entry>

              <entry>“hthor”</entry>

              <entry>No</entry>
            </row>

            <row>
              <entry>TraceToFile</entry>

              <entry align="left">When true, tracing is directed to file
              <emphasis role="bold">./HPCCJDBC.log</emphasis>, otherwise trace
              is sent to standard output (stdout)</entry>

              <entry>"false"</entry>

              <entry>No</entry>
            </row>

            <row>
              <entry>TraceLevel</entry>

              <entry align="left">Trace Logging level, as defined in
              java.util.logging.level. Valid values: ALL, SEVERE, WARNING,
              INFO, FINEST, OFF</entry>

              <entry>INFO</entry>

              <entry>No</entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable></para>

    <para>These configuration settings are used when creating an HPCC JDBC
    connection. </para>

    <para>They can be passed to the JDBC driver using the JDBC connection URL
    or as part of the connection properties object. When passed through the
    connection URL, the values must be URL-encoded.</para>
  </chapter>

  <chapter>
    <title>Using HPCC as a JDBC data source</title>

    <para>Once connected, the HPCC JDBC driver will process submitted SQL
    statements and generate dynamic ECL code. The code is submitted to and
    executed by your HPCC Platform. The resultset is returned to your
    application or SQL client.</para>

    <para><variablelist>
        <varlistentry>
          <term>Note:</term>

          <listitem>
            <para>The HPCC JDBC driver <emphasis role="bold">only supports
            files which contain the record definition in the logical file’s
            metadata.</emphasis> Sprayed files do not contain this metadata.
            This metadata exists on any file or index which is written to the
            HPCC Distributed File System. Sprayed data files typically undergo
            some processing and an OUTPUT of the transformed data to disk
            before use, so this should not interfere with the driver’s
            usefulness.</para>
          </listitem>
        </varlistentry>
      </variablelist></para>

    <para></para>

    <para>In addition, you can utilize indexes on the HPCC in one of two
    ways:</para>

    <orderedlist numeration="arabic">
      <listitem>
        <para>Provide SQL hints to tell driver to use a specific index for
        your query.</para>

        <para>For example:</para>

        <programlisting>USEINDEX(TutorialPersonByZipIndex)</programlisting>
      </listitem>

      <listitem>
        <para>Specify the related indexes in the HPCC logical file
        description.</para>
      </listitem>
    </orderedlist>

    <sect1 role="nobrk">
      <title>Index Annotations</title>

      <para>The JDBC driver attempts to perform index based reads whenever
      possible. However, in order to take advantage of index reads, the target
      HPCC files need to be annotated with the pertinent index file names.
      This is accomplished by adding the following key/value entry on the
      file’s description using ECL Watch.</para>

      <para>From a logical file’s details page, enter the information in the
      Description entry box, then press the <emphasis role="bold">Save
      Description</emphasis> button.</para>

      <para>This information is used by the driver to decide if an index fetch
      is possible for a query on the base file.</para>

      <sect2>
        <title><emphasis role="bold">On source file:</emphasis></title>

        <para><emphasis role="bold">XDBC:RelIndexes=
        [</emphasis><emphasis><emphasis
        role="bold"><emphasis>fullLogicalFilename1</emphasis></emphasis></emphasis><emphasis
        role="bold">;<emphasis>
        fullLogicalFilename2</emphasis></emphasis><emphasis
        role="bold">]</emphasis></para>

        <para></para>

        <para>Example:</para>

        <programlisting>XDBC:RelIndexes=[tutorial::yn::peoplebyzipindex;
                 tutorial::yn::peoplebyzipindex2;
                 tutorial::yn::peoplebyzipindex3]</programlisting>

        <para>In this example, the source file has three indexes
        available.</para>

        <para></para>
      </sect2>

      <sect2>
        <title><emphasis role="bold">On the index file:</emphasis></title>

        <para><emphasis
        role="bold">XDBC:PosField=[</emphasis><emphasis>indexPositionFieldName</emphasis><emphasis
        role="bold">]</emphasis></para>

        <para></para>

        <para>Example:</para>

        <programlisting>XDBC:PosField=[fpos]</programlisting>

        <para>The FilePosition field (fpos) can have any name, so it must be
        specified in the metadata so the driver knows which field is the
        fileposition.</para>

        <para>Simply enter the information in the description entry box, then
        press the <emphasis role="bold">Save Description</emphasis>
        button.</para>

        <para><emphasis role="bold">Note:</emphasis> You should enter this
        information BEFORE publishing any query using the data file or
        indexes. Published queries lock the file and would prevent editing the
        metadata.</para>

        <para></para>
      </sect2>
    </sect1>
  </chapter>

  <chapter>
    <title>Supported SQL</title>

    <sect1 role="nobrk">
      <title>CALL</title>

      <para><emphasis role="bold">Call
      </emphasis><emphasis>queryname</emphasis><emphasis role="bold">
      ([</emphasis><emphasis>param list</emphasis><emphasis
      role="bold">])</emphasis></para>

      <para><informaltable colsep="0" frame="none" rowsep="0">
          <tgroup cols="2">
            <colspec colwidth="113.65pt" />

            <colspec />

            <tbody>
              <row>
                <entry>queryName</entry>

                <entry>The published query name or alias</entry>
              </row>

              <row>
                <entry>paramList</entry>

                <entry>The parameters exposed by the published query
                (comma-separated)</entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable></para>

      <para>Call executes a published ECL query as if it were a stored
      procedure.</para>

      <para>Example:</para>

      <programlisting>Call SearchPeopleByZipService (‘33024’)</programlisting>

      <para></para>
    </sect1>

    <sect1>
      <title>SELECT</title>

      <para><emphasis role="bold">select [</emphasis>distinct<emphasis
      role="bold">]</emphasis> <emphasis>colummList</emphasis> <emphasis
      role="bold">from</emphasis> <emphasis>tableList </emphasis><emphasis>
      </emphasis><emphasis role="bold">[</emphasis>USE
      INDEX<emphasis>(indexFileName</emphasis> | 0
      <emphasis>)</emphasis><emphasis role="bold">]</emphasis></para>

      <para><emphasis role="bold">[where</emphasis>
      <emphasis>logicalExpression</emphasis><emphasis role="bold">]</emphasis>
      <emphasis role="bold">[group by</emphasis>
      <emphasis>columnList<superscript>1</superscript></emphasis><emphasis
      role="bold">]</emphasis> <emphasis role="bold">[having</emphasis>
      <emphasis>logicalExpression<superscript>2</superscript></emphasis><emphasis
      role="bold">]</emphasis></para>

      <para><emphasis role="bold">[order by</emphasis>
      <emphasis>columnList<superscript>1</superscript> </emphasis>[asc |
      desc]<emphasis> </emphasis>] <emphasis
      role="bold">[LIMIT</emphasis><emphasis> limitNumber</emphasis><emphasis
      role="bold">]</emphasis></para>

      <variablelist>
        <varlistentry>
          <term>NOTE:</term>

          <listitem>
            <para>Identifiers can be unquoted or within double quotes, literal
            string values must be single quoted.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <para><informaltable colsep="0" frame="none" rowsep="0">
          <tgroup cols="2">
            <colspec colwidth="123.45pt" />

            <colspec />

            <tbody>
              <row>
                <entry><emphasis>columnList</emphasis></entry>

                <entry>columnreference1[,columnreference2,columnreference3,...,columnreference<emphasis>n</emphasis>]</entry>
              </row>

              <row>
                <entry></entry>

                <entry>The column(s) to return (comma-separated list). In
                addition, these aggregate functions are supported : COUNT,
                SUM, MIN, MAX, and AVG. These work in a similar manner as
                their ECL counterparts.</entry>
              </row>

              <row>
                <entry></entry>

                <entry></entry>
              </row>

              <row>
                <entry>columnreference</entry>

                <entry>[tablename.]columnname[ [AS] alias ]</entry>
              </row>

              <row>
                <entry><emphasis></emphasis></entry>

                <entry></entry>
              </row>

              <row>
                <entry><emphasis>distinct</emphasis></entry>

                <entry>[distinct] col1, col2,...
                col<emphasis>n</emphasis></entry>
              </row>

              <row>
                <entry><emphasis></emphasis></entry>

                <entry>The result set will only contain distinct (unique)
                values.</entry>
              </row>

              <row>
                <entry></entry>

                <entry></entry>
              </row>

              <row>
                <entry><emphasis>tableList</emphasis></entry>

                <entry>tableref1[,tableref2,tableref3,...,tableref<emphasis>n</emphasis>]</entry>
              </row>

              <row>
                <entry></entry>

                <entry>One or more tables, separated by commas.</entry>
              </row>

              <row>
                <entry></entry>

                <entry><emphasis role="bold">NOTE: </emphasis>A table list
                with multiple tables creates an (one or more) implicit inner
                join using the where clause logical expression as the join
                condition which must contain an equality condition.</entry>
              </row>

              <row>
                <entry></entry>

                <entry></entry>
              </row>

              <row>
                <entry>tableref</entry>

                <entry>tableName[ [AS] alias ]</entry>
              </row>

              <row>
                <entry></entry>

                <entry>The Name of the table as referenced, optionally
                defining its alias.</entry>
              </row>

              <row>
                <entry></entry>

                <entry></entry>
              </row>

              <row>
                <entry><emphasis>alias</emphasis></entry>

                <entry>The alias used to refer to the corresponding table or
                field reference.</entry>
              </row>

              <row>
                <entry></entry>

                <entry></entry>
              </row>

              <row>
                <entry><emphasis>logicalExpression</emphasis></entry>

                <entry>Logical expression based on standard SQL filtering
                syntax.</entry>
              </row>

              <row>
                <entry></entry>

                <entry>BOOLEAN Only supports <emphasis>True</emphasis> or
                <emphasis>False</emphasis>, do not use Y, N, 0, or 1.</entry>
              </row>

              <row>
                <entry></entry>

                <entry><emphasis role="bold">Valid
                operators:</emphasis></entry>
              </row>

              <row>
                <entry></entry>

                <entry>= Equal (e.g., age=33)</entry>
              </row>

              <row>
                <entry></entry>

                <entry>&lt;&gt; Not equal (e.g., age &lt;&gt;33)</entry>
              </row>

              <row>
                <entry></entry>

                <entry>&gt; Greater than (e.g., age &gt;55)</entry>
              </row>

              <row>
                <entry></entry>

                <entry>&lt; Less than (e.g., age &lt; 18)</entry>
              </row>

              <row>
                <entry></entry>

                <entry>&gt;= Greater than or equal (e.g., age &gt;=21)</entry>
              </row>

              <row>
                <entry></entry>

                <entry>&lt;= Less than or equal (e.g., age &lt;=21)</entry>
              </row>

              <row>
                <entry></entry>

                <entry>IN(value1,value2,...,value<emphasis>n</emphasis>) where
                values are comma separated homogeneous types.</entry>
              </row>

              <row>
                <entry></entry>

                <entry>NOT IN(value1,value2,...,value<emphasis>n</emphasis>)
                where values are comma separated homogeneous types.</entry>
              </row>

              <row>
                <entry></entry>

                <entry></entry>
              </row>

              <row>
                <entry><emphasis>limitNumber</emphasis></entry>

                <entry>The number of rows to return. This overrides the
                driver’s configuration attribute (EclResultLimit ) but cannot
                be set to ALL.</entry>
              </row>

              <row>
                <entry></entry>
              </row>

              <row>
                <entry></entry>

                <entry><superscript>1</superscript>Aliasing not
                supported</entry>
              </row>

              <row>
                <entry></entry>

                <entry><superscript>2</superscript>Can only contain references
                to aggregate functions<superscript> </superscript>if used with
                <emphasis>having</emphasis> clause.</entry>
              </row>

              <row>
                <entry></entry>

                <entry>Aggregate functions can only be expressed in
                logicalExpressions by using <emphasis>Group by </emphasis>and
                <emphasis>having</emphasis></entry>
              </row>

              <row>
                <entry></entry>

                <entry><emphasis role="bold">Examples:</emphasis></entry>
              </row>

              <row>
                <entry></entry>

                <entry>Select * from tableList where Sum(F1 &gt; 100) /* is
                NOT SUPPORTED */</entry>
              </row>

              <row>
                <entry></entry>

                <entry>Select * from tableList Group byF1 Haveing Sum (F1 &gt;
                100) /* IS SUPPORTED */</entry>
              </row>

              <row>
                <entry></entry>

                <entry></entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable></para>

      <para>Example:</para>

      <programlisting>Select fname, lname, state from TutorialPerson where 
   state=’FL’ OR (lname='Smith' and fname='Joe') 
//returns data that looks like this:
John Doe FL 
Jim Smith FL 
Jane Row FL
Joe Smith CA

Select fname, lname, state from TutorialPerson where state=’FL’ AND lname &lt;&gt; ‘Smith’
//returns data that looks like this:
John Doe FL 
Jane Row FL </programlisting>

      <para>The driver supports SQL index hints, which gives the SQL user the
      option to specify the most appropriate HPCC index for the current SQL
      query. This also allows you to disable the use of an index.</para>

      <para><emphasis role="bold">select
      </emphasis><emphasis>columnList</emphasis> <emphasis role="bold"> from
      </emphasis><emphasis>tableName </emphasis><emphasis role="bold">USE
      INDEX(</emphasis><emphasis>hpcc::index::file::name</emphasis><emphasis
      role="bold">) where </emphasis><emphasis>logicalExprssions
      </emphasis></para>

      <para><emphasis role="bold">USE INDEX(0) </emphasis>forces the system to
      avoid seeking an index for the current query.</para>

      <para>Example:</para>

      <programlisting>Select fname, lname, zip, state from TutorialPerson 
USEINDEX(TutorialPersonByZipIndex)where zip=’33024’

//returns data that looks like this:
John Doe FL 33024
Jim Smith FL 33024
Jane Row FL 33024
</programlisting>

      <para></para>
    </sect1>

    <sect1>
      <title>SELECT JOIN</title>

      <para><emphasis role="bold">select
      </emphasis><emphasis>colummList</emphasis> <emphasis
      role="bold">from</emphasis> <emphasis>tableName <emphasis
      role="bold">[</emphasis></emphasis><emphasis
      role="bold">as</emphasis><emphasis> alias<emphasis
      role="bold">]</emphasis></emphasis><emphasis role="bold">
      </emphasis></para>

      <para><emphasis role="bold">[</emphasis>&lt;outer | inner &gt; <emphasis
      role="bold">JOIN </emphasis><emphasis>join TableName
      </emphasis><emphasis role="bold">[ as
      </emphasis><emphasis>alias</emphasis><emphasis role="bold">] on
      </emphasis><emphasis>joinCondition</emphasis><emphasis
      role="bold">]</emphasis></para>

      <para>[USE INDEX<emphasis>(</emphasis>indexFileName | 0
      <emphasis>)</emphasis>]</para>

      <para>[<emphasis role="bold">where</emphasis>
      <emphasis>logicalExpression] </emphasis>[<emphasis role="bold">group
      by</emphasis> <emphasis>fieldName</emphasis>]</para>

      <para>[<emphasis role="bold">order by</emphasis> <emphasis>columnNames
      </emphasis>[asc | desc]<emphasis> </emphasis>] [<emphasis
      role="bold">LIMIT</emphasis><emphasis> limitNumber</emphasis>]</para>

      <para><informaltable colsep="0" frame="none" rowsep="0">
          <tgroup cols="2">
            <colspec colwidth="123.45pt" />

            <colspec />

            <tbody>
              <row>
                <entry><emphasis>columnList</emphasis></entry>

                <entry>columnreference1[,columnreference2,columnreference3,...,columnreference<emphasis>n</emphasis>]</entry>
              </row>

              <row>
                <entry></entry>

                <entry>The column(s) to return (comma-separated list). In
                addition, these aggregate functions are supported : COUNT,
                SUM, MIN, MAX, and AVG. These work in a similar manner as
                their ECL counterparts.</entry>
              </row>

              <row>
                <entry></entry>

                <entry></entry>
              </row>

              <row>
                <entry>columnreference</entry>

                <entry>[tablename.]columnname[ [AS] alias ]</entry>
              </row>

              <row>
                <entry><emphasis></emphasis></entry>

                <entry></entry>
              </row>

              <row>
                <entry><emphasis>distinct</emphasis></entry>

                <entry>[distinct] col1, col2,...
                col<emphasis>n</emphasis></entry>
              </row>

              <row>
                <entry><emphasis></emphasis></entry>

                <entry>The result set will only contain distinct (unique)
                values.</entry>
              </row>

              <row>
                <entry></entry>

                <entry></entry>
              </row>

              <row>
                <entry><emphasis>alias</emphasis></entry>

                <entry>The alias used to refer to the corresponding table or
                field reference.</entry>
              </row>

              <row>
                <entry></entry>

                <entry></entry>
              </row>

              <row>
                <entry><emphasis role="bold">outer | inner</emphasis></entry>

                <entry>The type of JOIN to use.</entry>
              </row>

              <row>
                <entry></entry>

                <entry></entry>
              </row>

              <row>
                <entry><emphasis>joinTableName</emphasis></entry>

                <entry>The JOIN file to use.</entry>
              </row>

              <row>
                <entry></entry>

                <entry></entry>
              </row>

              <row>
                <entry><emphasis>joinCondition</emphasis></entry>

                <entry>Specifies the relationship between columns in the
                joined tables using logical expression.</entry>
              </row>

              <row>
                <entry></entry>

                <entry></entry>
              </row>

              <row>
                <entry><emphasis>logicalExpression</emphasis></entry>

                <entry>Logical expression based on standard SQL filtering
                syntax.</entry>
              </row>

              <row>
                <entry></entry>

                <entry>BOOLEAN Only supports <emphasis>True</emphasis> or
                <emphasis>False</emphasis>, do not use Y, N, 0, or 1.</entry>
              </row>

              <row>
                <entry></entry>

                <entry><emphasis role="bold">Valid
                operators:</emphasis></entry>
              </row>

              <row>
                <entry></entry>

                <entry>= Equal (e.g., age=33)</entry>
              </row>

              <row>
                <entry></entry>

                <entry>&lt;&gt; Not equal (e.g., age &lt;&gt;33)</entry>
              </row>

              <row>
                <entry></entry>

                <entry>&gt; Greater than (e.g., age &gt;55)</entry>
              </row>

              <row>
                <entry></entry>

                <entry>&lt; Less than (e.g., age &lt; 18)</entry>
              </row>

              <row>
                <entry></entry>

                <entry>&gt;= Greater than or equal (e.g., age &gt;=21)</entry>
              </row>

              <row>
                <entry></entry>

                <entry>&lt;= Less than or equal (e.g., age &lt;=21)</entry>
              </row>

              <row>
                <entry></entry>

                <entry>IN(value1,value2,...,value<emphasis>n</emphasis>) where
                values are comma separated homogeneous types.</entry>
              </row>

              <row>
                <entry></entry>

                <entry>NOT IN(value1,value2,...,value<emphasis>n</emphasis>)
                where values are comma separated homogeneous types.</entry>
              </row>

              <row>
                <entry></entry>

                <entry></entry>
              </row>

              <row>
                <entry><emphasis>limitNumber</emphasis></entry>

                <entry>Optional. The number of rows to return. This overrides
                the driver’s configuration attribute (<emphasis
                role="code">EclResultLimit </emphasis>) but cannot be set to
                ALL.</entry>
              </row>

              <row>
                <entry></entry>
              </row>

              <row>
                <entry></entry>

                <entry><superscript>1</superscript>Aliasing not
                supported</entry>
              </row>

              <row>
                <entry></entry>

                <entry><superscript>2</superscript>Can only contain references
                to aggregate functions<superscript> </superscript>if used with
                <emphasis>having</emphasis> clause.</entry>
              </row>

              <row>
                <entry></entry>

                <entry>Aggregate functions can only be expressed in
                logicalExpressions by using <emphasis>Group by </emphasis>and
                <emphasis>having</emphasis></entry>
              </row>

              <row>
                <entry></entry>

                <entry><emphasis role="bold">Examples:</emphasis></entry>
              </row>

              <row>
                <entry></entry>

                <entry>Select * from tableList where Sum(F1 &gt; 100) /* is
                NOT SUPPORTED */</entry>
              </row>

              <row>
                <entry></entry>

                <entry>Select * from tableList Group byF1 Having Sum (F1 &gt;
                100) /* IS SUPPORTED */</entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable></para>

      <para>Example:</para>

      <para><programlisting>Select t1.personname, t2.address 
       from persontable as t1 inner join addresstable as t2 
       on (t1.personid = t2.personid AND
           (t1.firstname = 'jim' AND
            t1.lastname  = 'smith' )) </programlisting></para>

      <para></para>

      <para>The JDBC driver does not convert parameter list or column list
      values to string literals.</para>

      <para>String values should be single quote encapsulated. Field
      identifier can be left unquoted or double quoted.</para>

      <para>For example, the table <emphasis role="bold">persons</emphasis>
      has columns Firstname(String) and Zip (numeric)</para>

      <para><programlisting>Select Firstname from persons where Firstname = ‘Jim’ and zip &gt; 33445    /* works  */ 

Select Firstname from persons where Firstname = ‘Jim’ and "zip" &gt; 33445    /* also works  */ 

Select Firstname from persons where Firstname = Jim and zip &gt; 33445     /* doesn’t work */

Select Firstname from persons where Firstname = ‘Jim’ and zip &gt; ‘33445’   /* doesn’t work */</programlisting></para>

      <para></para>
    </sect1>

    <sect1>
      <title>Supported Aggregate Functions</title>

      <para><emphasis
      role="bold">COUNT</emphasis>([DISTINCT]<emphasis>columnName</emphasis>)</para>

      <para><emphasis
      role="bold">DISTINCT</emphasis>(<emphasis>columnName</emphasis>)</para>

      <para><emphasis
      role="bold">SUM</emphasis>(<emphasis>columnName</emphasis>)</para>

      <para><emphasis
      role="bold">MIN</emphasis>(<emphasis>columnName</emphasis>)</para>

      <para><emphasis
      role="bold">MAX</emphasis>(<emphasis>columnName</emphasis>)</para>

      <para><emphasis
      role="bold">AVG</emphasis>(<emphasis>columnName</emphasis>)</para>

      <para>These aggregate functions are supported. They behave as their ECL
      counterparts. See the <emphasis role="bold">ECL Language
      Reference</emphasis> for details.</para>

      <para><informaltable colsep="0" frame="none" rowsep="0">
          <tgroup cols="2">
            <colspec colwidth="119.65pt" />

            <colspec />

            <tbody>
              <row>
                <entry>COUNT</entry>

                <entry>Counts the occurrences of columnName in the result,
                always an integer.</entry>
              </row>

              <row>
                <entry>DISTINCT</entry>

                <entry>Returns only distinct values of columnName in the
                result, output type is dependent on input type.</entry>
              </row>

              <row>
                <entry>SUM</entry>

                <entry>Returns the sum of the values of columnName in the
                result, output type is dependent on input type.</entry>
              </row>

              <row>
                <entry>MIN</entry>

                <entry>Returns the minimum value for of columnName in the
                result, output type is dependent on input type.</entry>
              </row>

              <row>
                <entry>MAX</entry>

                <entry>Returns the minimum value for of columnName in the
                result, output type is dependent on input type.</entry>
              </row>

              <row>
                <entry>AVG</entry>

                <entry>Returns the average of the values of columnName in the
                result, always a real number.</entry>
              </row>

              <row>
                <entry>columnName</entry>

                <entry>The column to aggregate.</entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable></para>

      <para>Example:</para>

      <para><programlisting>Select fname, lname, state, COUNT(zip) from TutorialPerson where zip=’33024’</programlisting></para>

      <sect2>
        <title>Supported String Modifiers</title>

        <para><emphasis
        role="bold">UPPER</emphasis>(<emphasis>columnName</emphasis>)</para>

        <para><emphasis
        role="bold">LOWER</emphasis>(<emphasis>columnName</emphasis>)</para>

        <para></para>

        <informaltable colsep="0" frame="none" rowsep="0">
          <tgroup cols="2">
            <colspec colwidth="119.65pt" />

            <colspec />

            <tbody>
              <row>
                <entry>UPPER</entry>

                <entry>Returns with all lower case characters converted to
                upper case.</entry>
              </row>

              <row>
                <entry>LOWER</entry>

                <entry>Returns with all upper case characters converted to
                lower case.</entry>
              </row>

              <row>
                <entry>columnName</entry>

                <entry>The column to aggregate</entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>
      </sect2>
    </sect1>
  </chapter>

  <chapter>
    <title>Java Example</title>

    <para><programlisting>/* Obtain instance of JDBC Driver */
Driver jdbcdriver = DriverManager.getDriver("jdbc:hpcc");
        
/* Establish Connection */
       
HPCCConnection connection = null;
 try
 {
        
/*populate JAVA properties object with pertinent connection options */
   Properties connprops = new Properties();
   connprops.put("ServerAddress", "192.168.124.128");

/*or create JDBC connection url string with pertinent connection options*/
/* the connection values must be URL-encoded */
   String jdbcurl = "jdbc:hpcc;ServerAddress=HTTP%3A%2F%2F192.168.124.128";

/*provide all necessary connection properties either by URL, or props object */
    connection = (HPCCConnection) driver.connect(jdbcurl, connprops);
  }
 
   catch (Exception e) { System.out.println("Error");}
/* create HPCCStatement object for single use SQL query execution */

   HPCCStatement stmt = (HPCCStatement) connection.createStatement();

/* Create your SQL query */
   String mysql = "select * from tablename as mytab limit 10";

/* Execute your SQL query */
   HPCCResultSet res1 = (HPCCResultSet) stmt.executeQuery(mysql);

/*Do something with your results */
   printOutResultSet(res1);

/* Or create a prepared statement for multiple execution and parameterization */
   String myprepsql = "select * from persons_table persons where zip= ? limit 100";
   HPCCPreparedStatement prepstmt =
(HPCCPreparedStatement)createPrepStatement(connection, myprepsql);

/* provide parameter values and execute */
   for (int i = 33445; i &lt; 33448; i++)
   {
    prepstmt.clearParameters();
    prepstmt.setString(1, "'" + Integer.toString(i, 10) + "'");
    HPCCResultSet qrs = (HPCCResultSet) ((HPCCPreparedStatement) prepstmt).executeQuery();

/*Do something with your results */
    printOutResultSet(qrs);
   }


</programlisting>More code samples available from:</para>

    <para><ulink
    url="https://github.com/hpcc-systems/hpcc-jdbc/blob/master/src/org/hpccsystems/jdbcdriver/tests/HPCCDriverTest.java">https://github.com/hpcc-systems/hpcc-jdbc/blob/master/src/org/hpccsystems/jdbcdriver/tests/HPCCDriverTest.java</ulink></para>
  </chapter>
</book>
